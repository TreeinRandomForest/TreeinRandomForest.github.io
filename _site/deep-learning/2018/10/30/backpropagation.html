<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Detailed Look at Backpropagation in Feedforward Neural Networks</title>
  <meta name="description" content="The last few years have shown an enormous rise in the use of neural networks for supervised-learning tasks. This growth has been driven by multiple factors -...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://treeinrandomforest.github.io/deep-learning/2018/10/30/backpropagation.html">
  <link rel="alternate" type="application/rss+xml" title="The Happy Mathematician" href="http://treeinrandomforest.github.io/feed.xml">

<!--thanks to Davide Cervone-->
<!--https://groups.google.com/forum/#!msg/mathjax-users/SXjY3rQXOzc/YGcc48HwDR4J-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
    var TEX = MathJax.InputJax.TeX,
        MML = MathJax.ElementJax.mml;
    var CheckDimen = function (dimen) {
      if (dimen === "" ||
          dimen.match(/^\s*([-+]?(\.\d+|\d+(\.\d*)?))\s*(pt|em|ex|mu|px|mm|cm|in|pc)\s*$/))
              return dimen.replace(/ /g,"");
      TEX.Error("Bad dimension for image: "+dimen);
    };
    TEX.Definitions.macros.img = "myImage";
    TEX.Parse.Augment({
      myImage: function (name) {
        var src = this.GetArgument(name),
            valign = CheckDimen(this.GetArgument(name)),
            width  = CheckDimen(this.GetArgument(name)),
            height = CheckDimen(this.GetArgument(name));
        var def = {src:src};
        if (valign) {def.valign = valign}
        if (width)  {def.width  = width}
        if (valign) {def.height = height}
        this.Push(this.mmlToken(MML.mglyph().With(def)));
      }
    });
  });
  </script>

 <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
       <script type="text/x-mathjax-config">
         MathJax.Hub.Config({
           tex2jax: {
             inlineMath: [ ['$','$'], ["\\(","\\)"] ],
             processEscapes: true
           }
         });
       </script>
       <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">The Happy Mathematician</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A Detailed Look at Backpropagation in Feedforward Neural Networks</h1>
    <p class="post-meta"><time datetime="2018-10-30T00:00:00-04:00" itemprop="datePublished">Oct 30, 2018</time></p>
  </header>
  
  <div class="post-content" itemprop="articleBody">
    <p>The last few years have shown an enormous rise in the use of neural networks for supervised-learning tasks. This growth has been driven by multiple factors - exponentially more labeled data to train with, faster and cheaper GPUs (graphics processing units) that parallelize linear algebra operations used extensively by deep learning, as well as a better understanding of the process of neural network training.</p>

<p>At the same time, the core training algorithm used to train neural networks is still <strong>backpropagation</strong> and <strong>gradient descent</strong>. While there are many excellent frameworks like <a href="https://www.tensorflow.org/">TensorFlow</a> and <a href="https://pytorch.org/">PyTorch</a> that take care of the details for the modern machine learning practitioner, it is crucial to understand what they do under the hood. The first step in that journey is understanding what backpropagation actually is.</p>

<h1 id="global-view-of-the-training-process">Global View of the Training Process</h1>

<p>One can view a neural network as a black box that maps certain input vectors $\vec{x}$ to output vectors $\vec{y}$. More formally, the neural network is a function, $f$:</p>

<script type="math/tex; mode=display">\vec{y} = f(\vec{x})</script>

<p>$f$ depends on several underlying parameters, also known as weights, denoted by $\vec{w}$:</p>

<script type="math/tex; mode=display">\vec{y} = f(\vec{x}; \vec{w})</script>

<p>The situation isn’t unlike linear regression where the output $y$:</p>

<script type="math/tex; mode=display">y = w_1 x_1 + w_2 x_2 + \ldots + w_n x_n = \vec{w}.\vec{x}</script>

<p>is a function of the input $\vec{x}$ with some parameters $\vec{w}$.</p>

<p>Time for some pedantry - technically both $\vec{x}$ and $\vec{w}$ are inputs to $f$ and this distinction between the “inputs” $\vec{x}$ and the “weights” $\vec{w}$ seems silly. The separation actually encodes the beautiful idea that $f$ actually denotes a <em>family</em> of functions, one for each particular $\vec{w}$ and the central duty of any machine learning algorithm is to pick one function out of the family so that it best describes/understands our data. One can make this more explicit by writing $f_{\vec{w}}(\vec{x})$ instead of $f(\vec{x}; \vec{w})$ but the latter is easier to write notationally.</p>

<p>The central problem then is the discovery of the correct $\vec{w}$. What does that even mean? Well, given a dataset with input vectors and the corresponding outputs (labels), one uses $f$ with random weights $\vec{w}$ to make predictions, measures the deviation between the predictions and labels and tweaks the weights to minimize the deviation.</p>

<p>As an example, one commonly used measure of deviation is <strong>mean-squared error</strong> which is especially useful for regression problems. Another one commonly used is <strong>cross-entropy</strong> (or <strong>negative-log-likelihood</strong>) which is used for classification problems. There are many more and you can/should write your own depending on the problem you are solving. For simplicity, we’ll use mean-squared error below but the discussion is minimally changed if one uses a different error metric.</p>

<p>The mean-squared error measures the deviation between the label $y$ and the prediction $\hat{y}$ as:</p>

<script type="math/tex; mode=display">error = \frac{(\hat{y}-y)^2}{2}</script>

<p>Dividing by 2 is purely a convention that will become clear later on. If the label and prediction agree, this error is 0 and the more they disagree, the higher the error. For a dataset, one would just average the errors:</p>

<script type="math/tex; mode=display">C = \frac{1}{n} \Sigma_{i=0}^{n} \frac{(\hat{y}\_i-y_i)^2}{2}</script>

<p>where we introduced the symbol $C$ which stands for <strong>cost</strong>. The terms <strong>cost</strong>, <strong>loss</strong>, <strong>error</strong>, <strong>deviance</strong> are often used interchangeably but we’ll stick to cost from now on. $n$ is the number of examples in the dataset and the symbol $\Sigma$ (capital “Sigma”) denotes a sum over all the errors.</p>

<p>Since the predictions, $\hat{y}_i = f(\vec{x}_i; \vec{w})$ are functions of $\vec{w}$, $C$ actually depends on $\vec{w}$ as well:</p>

<script type="math/tex; mode=display">C[\vec{w}] = \frac{1}{n} \Sigma_{i=0}^{n} \frac{(f(\vec{x}\_i; \vec{w})-y_i)^2}{2}</script>

<p>where we made $C[\vec{w}]$ denotes $C$’s dependence on $\vec{w}$ .</p>

<p>We would now pick some random $\vec{w}$, make predictions $f(\vec{x}_{i}; \vec{w})$ and compute the cost $C[\vec{w}]$. Our next task is to tweak $\vec{w}$ and repeat the procedure so that $C[\vec{w}]$ decreases. Our end goal is to minimize the cost, $C[\vec{w}]$ and the set of weights $\vec{w}$ that would do that would define our final model.</p>

<p>The big question here is two-fold:</p>
<ul>
  <li>
    <p>How should we choose the initial weights, $\vec{w}^{(0)}$ (the “0” denotes “initial”)?</p>
  </li>
  <li>
    <p>Once we compute $C[\vec{w}^{(t)}]$ with a given $\vec{w}^{(t)}$, how should we choose the next $\vec{w}^{(t+1)}$ so that <strong>in the long run</strong>, we decrease $C[\vec{w}]$?</p>
  </li>
</ul>

<p>There’s some new notation above so let’s take a moment to clearly define what we mean:</p>

<p>Think of the process of updating the weights $\vec{w}$ as a process that occurs once every second. At time $t=0$, we start with a randomly generated $\vec{w}^{(0)}$. At time $t$, the weights will be $\vec{w}^{(t)}$. We want a rule to go from $\vec{w}^{(t)}$ to $\vec{w}^{(t+1)}$, i.e. from time-step $t$ to time-step $t+1$.</p>

<p>One way to minimize $C[\vec{w}]$ is a “greedy” approach. Let’s look at a simple example that is one-dimensional i.e. there’s only one element in $\vec{w}$ called $w$, which is a real number:</p>

<table class="image">
  <caption align="bottom">Fig 1. A simple cost function in one variable i.e. with one weight</caption>
  <tr><td><img src="/assets/backprop/gradientdescent.svg" alt="Fig 1. A simple cost function in one variable i.e. with one weight" class="center" /></td></tr>
  <tr><td>&nbsp;</td></tr>
</table>

<p>This is a nice situation where there is exactly one minimum at $w_{*}$. Let’s suppose, we are at $w_{R}$ ($R$ denotes “right” and $L$ denotes “left”). We know we need to move to the left or in the negative direction. We also know the slope of the cost curve is positive (“pointing up”) at $w_R$. On the other hand, suppose we are at $w_L$. We need to move to the right or in the positive direction while the slope is negative (“pointing down”) at $w_L$.</p>

<p>In other words:</p>
<ul>
  <li>When the slope of the cost function is positive, we need to move the weight in the negative direction i.e. decrease the weight.</li>
  <li>When the slope is negative, we need to move the weight in the positive direction i.e. increase the weight.</li>
</ul>

<p>Mathematically,</p>

<script type="math/tex; mode=display">w^{(t+1)} = w^{(t)} - \text{(something)} \text{(sign of slope)}</script>

<p>where $\text{something}$ is a positive number (so it won’t change the sign of the term) which signifies the magnitude of the change in $w^{(t)}$.</p>

<p>When the slope is positive, we get:</p>

<p>$w^{(t+1)} = w^{(t)} - \text{(positive)} \text{(positive)} = w^{(t)} - \text{positive}$</p>

<p>i.e. $w^{(t+1)} &lt; w^{(t)}$ so we moved in the negative direction.</p>

<p>When the slope is negative, we get:</p>

<p>$w^{(t+1)} = w^{(t)} - \text{(positive)} \text{(negative)} = w^{(t)} + \text{positive}$</p>

<p>i.e. $w^{(t+1)} &gt; w^{(t)}$ so we moved in the positive direction.</p>

<p>We still need to decide what $\text{something}$ is. It’s usually taken to be proportional to the magnitude of the slope:</p>

<script type="math/tex; mode=display">w^{(t+1)} = w^{(t)} - \eta \mid{\frac{dC[w^{(t)}]}{dw}}\mid \text{(sign of slope)}</script>

<p>where $\eta$ is a constant of proportionality called the <strong>learning rate</strong>, $\mid\frac{dC[w^{(t)}]}{dw}\mid$ is the absolute value of the slope (or derivative) at the point $w^{(t)}$. We don’t need to separate out the magnitude of the slope and the sign of the slope and we can simply write:</p>

<script type="math/tex; mode=display">w^{(t+1)} = w^{(t)} - \eta \frac{dC[w^{(t)}]}{dw} \label{graddesc}</script>

<p>This generalizes easily to a cost function depending on multiple weights $\vec{w}$. We just compute the derivative of the cost with respect to each element of $\vec{w}$ and update the weights according to equation $\ref{graddesc}$. In particular, if $\vec{w} = (w_1, w_2, \ldots, w_N)$ are the $N$ weights, we compute the partial derivatives, $\frac{\partial C}{\partial w_i}$ for each $i$ and update each weight as follows:</p>

<script type="math/tex; mode=display">w_i^{(t+1)} = w_i^{(t)} - \eta \frac{\partial C[\vec{w}^{(t)}]}{\partial w_i} \label{multidimgd1}</script>

<p>This is usually written more succinctly as:</p>

<script type="math/tex; mode=display">\vec{w}^{(t+1)} = \vec{w}^{(t)} - \eta \nabla C[\vec{w}^{(t)}] \label{multidimgd2}</script>

<p>but ignore the extra notation here for now. The two equations $\ref{multidimgd1}$ and $\ref{multidimgd2}$ are completely equivalent.</p>

<p><strong>The main takeaway from the above discussion is that we <em>really really</em> care about the derivatives of the cost with respect to the weights since we need them to update the weights to minimize the cost and to hopefully get a well-performing model. If we can find an efficient way to do so, it would make it possible to train neural networks on non-trivial datasets. That efficient way is backpropagation.</strong></p>

<p>In the discussion below, we’ll assume mean-squared error and exactly one data point. Both of these assumptions are straightforward to remove.</p>

<p>Some other assumptions/prerequisites/notes before we start:</p>

<ul>
  <li>You’ll need some familiarity with matrices and matrix multiplication as well as differentiation from calculus (but no integration at all).</li>
  <li>Ideally, get a few sheets of paper, a pen and a quiet space and work through the calculations as you go along. Writing something out cements the material far more than just reading it.</li>
  <li>Unfortunately I don’t know how to show the details without mathematics. Please don’t be turned off by unusual symbols - they are just strokes on a piece of paper or pixels on a screen. There is often a debate about the importance of mathematical content in machine learning and deep learning. While it is true that one doesn’t need to know the mathematical details to apply many of these techniques (at least at a basic level) and that many papers use mathematics to obscure instead of illuminate concepts, mathematics gives a precise and beautiful understanding of what these algorithms are doing. It is still our most direct probe into complex systems and most of all, it is fun.</li>
  <li>What you’ll hopefully take away is that after all the fog clears, the simple act of calculating derivatives for this problem results in simple, iterative equations that let us train neural networks very efficiently.</li>
  <li>There’ll be a follow-up entry on <em>implementing</em> backpropagation from scratch and tweaks to gradient descent.</li>
  <li>Lastly, backpropagation is probably deeply flawed. There are some big questions here - 1) do animal brains actually learn via a mechanism like backpropagation, 2) are there alternatives that lead to better solutions in far shorter amount of time and with small amounts of data, 3) what is the exact nature of the so-called cost landscape i.e. the behavior of the cost as a function of the weights. As you read the article below, I urge you to be bold and think of alternatives to backpropagation.</li>
</ul>

<h2 id="backpropagation-i---linear-activations">Backpropagation I - linear activations</h2>

<p>We will be working with a very simple network architecture in this section. The architecture is shown in figure 2 below:</p>

<table class="image">
  <caption align="bottom">Fig 2. A simple feedforward linear neural network</caption>
  <tr><td><img src="/assets/backprop/nn_1.svg" alt="Fig 2. A simple feedforward linear neural network" class="center" /></td></tr>
  <tr><td>&nbsp;</td></tr>
</table>

<p>There is an input node taking a number $x_0$, two internal nodes with values $x_1$ and $x_2$ respectively and an output node with value $x_3$ (also denoted as $\hat{y}$, as before).</p>

<p>There are three weights: $w_{01}$, $w_{12}$, and $w_{23}$ respectively. You should read $w_{ij}$ as the weight “transforming the value at node i to the value at node j”.</p>

<p>More precisely, forward propagation or inference or prediction in this architecture is:</p>

<p>$x_1 = w_{01} x_0$</p>

<p>$x_2 = w_{12} x_1$</p>

<p>$\hat{y} \equiv x_3 = w_{23} x_2$</p>

<p>We can substitude the values iteratively to get:</p>

<p>$x_3 = w_{23} x_2 = w_{23} w_{12} x_1 = w_{23} w_{12} w_{01} x_0$</p>

<p>In other words, given an input $x_0$, our function $f$ will predict $x_3$ defined above.</p>

<p>There is something silly going on here. Why would we have all these weights when we can define a new weight, say $w_{c} \equiv w_{23} w_{12} w_{01}$ (the “c” stands for combined) and define the following architecture going straight from the input to the output</p>

<table class="image">
  <caption align="bottom">Fig 3. Simplified neural network with combined weights</caption>
  <tr><td><img src="/assets/backprop/nn_1_short.svg" alt="Fig 3. Simplified neural network with combined weights" class="center" /></td></tr>
  <tr><td>&nbsp;</td></tr>
</table>

<p>$x_3 = w_c x_0$</p>

<p>You are absolutely right if you made that observation and it’s a very important point. Just combining these “linear” nodes doesn’t do anything. We need to add non-linearities to be able to learn arbitrarily complicated functions $f$. But for now, bear with me since this sections lays the groundwork for the next section where we introduce non-linearities into the network architecture.</p>

<p>Going back to our network, to execute gradient descent, we need to calculate all the derivatives of the cost function with respect to the weights.</p>

<p>If we only had one data point $x_0$ with our prediction $x_3$ and the actual value $y$, the cost would be</p>

<p>$C[\vec{w}] = C[w_{01}, w_{12}, w_{23}] = \frac{(x_3 - y)^2}{2}$</p>

<p>Expanding, we get</p>

<p>$C[\vec{w}] = \frac{1}{2} (w_{23} w_{12} w_{01} x_0 - y)^2$</p>

<p>We can now calculate the derivatives by using some basic calculus:</p>

<p>$\frac{\partial C}{\partial w_{23}} = \frac{1}{2} 2 (x_3 - y) \frac{\partial x_3}{\partial w_{23}}<br />
= (x_3 - y) w_{12} w_{01} x_0<br />
$</p>

<p>$\frac{\partial C}{\partial w_{12}} = (x_3-y) w_{23} w_{01} x_0$</p>

<p>$\frac{\partial C}{\partial w_{01}} = (x_3-y) w_{23} w_{12} x_0$</p>

<p>We see a couple of patterns here:</p>

<ul>
  <li>There is one derivative for each weight.</li>
  <li>The factor of $\frac{1}{2}$ was useful because the derivative “pulls down” a factor of 2 from $(x_3-y)^2$ and the factors cancel out.</li>
  <li>Each derivative is proportional to $(x_3 - y)$ or the deviation between the prediction and the target/label. If the deviation is 0, then all the derivatives are 0 and there are no corrections to the weights during gradient descent, as should be the case.</li>
  <li>One can think of two “chains” - a forward chain and a backward chain.
    <ul>
      <li>Forward chains look like:
        <ul>
          <li>$x_0$</li>
          <li>$w_{01} x_0$ (same as $x_1$)</li>
          <li>$w_{12} w_{01} x_0$ (same as $x_2$)</li>
          <li>$w_{23} w_{12} w_{01} x_0$ (same as $x_3$)</li>
        </ul>
      </li>
      <li>Backward chains look like:
        <ul>
          <li>$(x_3 - y)$</li>
          <li>$w_{23} (x_3 - y)$</li>
          <li>$w_{12} w_{23} (x_3 - y)$</li>
          <li>$w_{01} w_{12} w_{23} (x_3 - y)$</li>
        </ul>
      </li>
      <li>Both forward and backward chains show up in the derivatives.</li>
    </ul>
  </li>
</ul>

<p>In other words, forward chains are what one would get if one walks from the left to the right of the network and multiplies the factors together. Backward chains are what one would get if one walked from the right to the left.</p>

<p>To make the above point clearer, let’s rewrite the derivatives with the weights in order from left to right and any <strong>missing weight is colored in red</strong>.</p>

<p>$\frac{\partial C}{\partial w_{23}} = (x_3 - y) {\color{red} {w_{23}}} w_{12} w_{01} x_0<br />
$</p>

<p>$\frac{\partial C}{\partial w_{12}} = (x_3-y) w_{23} {\color{red} {w_{12}}} w_{01} x_0$</p>

<p>$\frac{\partial C}{\partial w_{01}} = (x_3-y) w_{23} w_{12} {\color{red} {w_{01}}} x_0$</p>

<p>Let’s introduce some more notation for the backward chains. We will use the Greek symbol “delta”, $\delta$ since it stands for the English “d” for “difference” or “deviance” and is a conventional symbol used for $x_3-y$ which measures the error.</p>

<p>Define:</p>

<p>$\delta_0 = x_3-y$</p>

<p>$\delta_1 = w_{23} (x_3 - y) = {\color{green} {w_{23}\delta_0}}$</p>

<p>$\delta_2 = w_{12} w_{23} (x_3 - y) = {\color{green} {w_{12}\delta_1}}$</p>

<p>$\delta_3 = w_{01} w_{12} w_{23} (x_3 - y) = {\color{green} {w_{01} \delta_2}}$</p>

<p>Using these new symbols, we can write the derivatives in a very simple manner:</p>

<p>$\frac{\partial C}{\partial w_{23}} = \underbrace{(x_3 - y)}_{\delta_0} {\color{red} {w_{23}}} \underbrace{w_{12} w_{01} x_0}_{x_2} = \delta_0 x_2<br />
$</p>

<p>$\frac{\partial C}{\partial w_{12}} = \underbrace{(x_3-y) w_{23}}_{\delta_1} {\color{red} {w_{12}}} \underbrace{w_{01} x_0}_{x_1} = \delta_1 x_1$</p>

<p>$\frac{\partial C}{\partial w_{01}} = \underbrace{(x_3-y) w_{23} w_{12}}_{\delta_2} {\color{red} {w_{01}}} \underbrace{x_0}_{x_0} = \delta_2 x_0$</p>

<p>In other words, we always get the combination $\delta_{A} x_{B}$ where $A+B=2$ and $B$ (subscript of $x$) is the source of the weight with respect to which we are taking the derivative. So,</p>

<p>$\frac{\partial C}{\partial w_{i,i+1}} = \delta_{2-i} x_i$</p>

<p>There is no magic about the “2”. It is the number of hidden layers i.e. the number of nodes excluding the input and the output nodes.</p>

<p>The main advantage here is that as one makes predictions, one has to calculate the forward chains - $x_1, x_2, x_3$ and once one calculates the deviation $(x_3 - y)$, calculating the backward chains is just an iterative multiplication by the weights but going in the reverse direction. So in two passes through the network, one can calculate all the derivatives.</p>

<p>To get a sense of why this is so promising, imagine we knew nothing about backpropagation and someone handed us the neural network in Fig 2. To calculate the derivatives, we could use finite differences. For example,</p>

<script type="math/tex; mode=display">\frac{\partial C[w_{01}, w_{12}, w_{23}]}{\partial w_{01}} \approx \frac{C[w_{01} + \epsilon, w_{12}, w_{23}] - C[w_{01}-\epsilon, w_{12}, w_{23}]}{2\epsilon}</script>

<p>where $\epsilon$ is some pre-decided small number ($\approx$ stands for “approximately equal to”). This basically exploits the definition of a derivative:</p>

<script type="math/tex; mode=display">\frac{df(x)}{dx} = \lim_{\epsilon\rightarrow 0} \frac{f(x+\epsilon) - f(x)}{\epsilon}</script>

<p>If $\epsilon$ is small enough, we’ll have a reasonably accurate estimate of the derivative. Since we are numerically (as opposed to analytically) computing the derivative, $\frac{f(x+\epsilon) - f(x-\epsilon)}{2\epsilon}$ is better behaved but let’s not worry about that. The main point is that to numerically evaluate the <em>approximation</em> of the derivative, we have to do forward propagation <em>twice</em> - once to calculate $C[w_{01} + \epsilon, w_{12}, w_{23}]$ and once to calculate $C[w_{01} - \epsilon, w_{12}, w_{23}]$. All this for just <em>one</em> damn derivative. If we have $N$ weights, we’ll end up doing two forward propagations for each one to do a total of <strong>$2N$</strong> forward propagation passes!!!! and only get approximate derivatives! Compare that to the one forward and one backward pass we did with our iterative equation above to get the derivative without any numerical approximation errors.</p>

<p>So far so good but this is still just a linear neural network with nothing interesting going on. Let’s add non-linearities into the mix and hope that this story repeats.</p>

<h2 id="backpropagation-ii---non-linear-activations">Backpropagation II - non-linear activations</h2>

<p>We will still maintain the same overall architecture. The new twist is an extra operation at each node.</p>

<p>A <strong>linear</strong> function $g(\vec{x})$ is any function with the following property:</p>

<p>$g(a\vec{x} + b\vec{y}) = ag(\vec{x}) + bg(\vec{y})$</p>

<p>where $a, b$ are constant real numbers and $\vec{x}, \vec{y}$ are $n$-dimensional vectors.</p>

<p>The simplest example of a linear function is $f(x) = \alpha x$. Then,</p>

<p>$f(ax+by) = \alpha (ax+by) = a (\alpha x) + b (\alpha y) = a f(x) + b f(y)$.</p>

<p>An example of a function that is not linear (<strong>non-linear</strong>) is $f(x) = \sqrt{x}$. A simple counterexample suffices - $f(4) = 2, f(9) = 3$ but $f(4+9) = \sqrt{13} \neq f(4)+f(9)=5$.</p>

<p>Linear functions can be very useful and the whole subject of <strong>linear algebra</strong> studies mathematical objects called vector spaces and linear functions between them. But most real systems in the world are not linear. Think of height as a function of age - it doesn’t increase by the same amount each year but instead stabilizes and even decreases with age. We want our neural network to be able to learn arbitrary non-linear functions. To enable this, we need to sprinkle some non-linear functions at various points throughout our architecture.</p>

<table class="image">
  <caption align="bottom">Fig 4. Feedforward neural network with non-linear functions $\sigma_i$ inserted.</caption>
  <tr><td><img src="/assets/backprop/nn_2.svg" alt="Fig 4. Feedforward neural network with non-linear functions $\sigma_i$ inserted." class="center" /></td></tr>
  <tr><td>&nbsp;</td></tr>
</table>

<p>In figure 4, each box represents one of our original nodes split into two operations. At each node, we now define two numbers:</p>

<p>$p_i$ is the value <strong>before</strong> the non-linear function is applied (p is for “pre”)</p>

<p>$q_i$ is the value <strong>after</strong> the non-linear function is applied (q since it comes after p)</p>

<p>and $i$ denotes which layer/node we are talking about. The non-linear function, also commonly known as the <strong>activation function</strong> or just <strong>activation</strong> is denoted by $\sigma_i$. This can potentially be different at every single layer/node.</p>

<p>Forward propagation is now modified with every original forward propagation equation split into two:</p>

<p>$p_0 = x_0 \text(input) \rightarrow q_0 = \sigma_0(p_0)$</p>

<p>$p_1 = w_{01} q_0 \rightarrow q_1 = \sigma_1(p_1)$</p>

<p>$p_2 = w_{12} q_1 \rightarrow q_2 = \sigma_2(p_2)$</p>

<p>$p_3 = w_{23} q_2 \rightarrow q_3 = \sigma_3(p_3) \text(output)$</p>

<p>The input $x_0$ is now denoted by $p_0$ for notational consistency. $p_0$ is now fed to the activation function $\sigma_0$ to get $q_0$. $q_0$ is now the input to the second layer. This process repeats till we get $q_3$ at the end which is the output of the model.</p>

<p>As a special case, consider $\sigma_i(x) = id(x) = x$ where $id$ denotes the identity function that maps every input to itself - $id(x) = x$. In that case, $p_i = q_i$ and we get our old linear neural network back.</p>

<p>To be more explicit about the output $q_3$’s dependence on the weights, we can combine the equations:</p>

<p>$q_3 = \sigma_3(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))$</p>

<p>As before, we compute the cost function to compare the output to the label:</p>

<p>$C[\vec{w}] = C[w_{01}, w_{12}, w_{23}] = \frac{(q_3-y)^2}{2}$</p>

<p>or more explicitly:</p>

<p>$C[\vec{w}] = \frac{(\sigma_3(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))-y)^2}{2}$</p>

<p>Let’s take a step back and realize that we really haven’t done anything very different. All we did was add 4 activations to our neural network, compute the output and evaluate the cost to see how well we did. As before what we really care about are the derivatives of the cost with respect to the weights so we can do gradient descent.</p>

<p>Using the chain rule from calculus, we can explicitly compute the derivatives (and write all the terms explicitly for clarity):</p>

<p>$\frac{\partial C}{\partial w_{23}} = \underline{(q_3-y)} \space \underline{\sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))} \space \underline{\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))}$</p>

<p>$\frac{\partial C}{\partial w_{12}} = \underline{(q_3-y)} \space \underline{\sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))} \space \underline{w_{23}}\space \underline{\sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))} \space \underline{\sigma_1(w_{01}\sigma_0(p_0))}$</p>

<p>$\frac{\partial C}{\partial w_{01}} = \underline{(q_3-y)}\space \underline{\sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))} \space \underline{w_{23}} \space \underline{\sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))} \space \underline{w_{12}} \space \underline{\sigma_1’(w_{01}\sigma_0(p_0))}\space\underline{\sigma_0(p_0)} $</p>

<p>Here $\sigma’(x)$ is short-hand notation for $\frac{d\sigma}{dx}$ to prevent the notation from getting heavy. The underlines are to delineate various terms that show up.</p>

<p>This is promising! We can already do some sanity checks and make a few observations:</p>

<p>Sanity checks:</p>
<ul>
  <li>All the derivatives are proportional to $(q_3-y)$. In other words, if your prediction is exactly equal to the label, there are no derivatives and hence no gradient descent to do which is precisely what one would expect.</li>
  <li>If we replace all the activations by the identity function, $id(x) = x$ with $id’(x) = 1$, then we can replace the derivatives with 1, all the $q_i = p_i = x_i$ and we recover the derivatives for Case I without the activation functions.</li>
</ul>

<p>Some observations:</p>
<ul>
  <li>We still get both forward chains and backward chains:
    <ul>
      <li>Forward chains now look like:
        <ul>
          <li>${\color{blue} {p_0}}$</li>
          <li>$\sigma_0(p_0) = {\color{blue} {q_0}}$</li>
          <li>$w_{01} \sigma_0(p_0) = {\color{blue} {p_1}}$</li>
          <li>$\sigma_1(w_{01} \sigma_0(p_0)) = {\color{blue} {q_1}}$</li>
          <li>$w_{12} \sigma_1(w_{01} \sigma_0(p_0)) = {\color{blue} {p_2}}$</li>
          <li>$\sigma_2(w_{12} \sigma_1(w_{01} \sigma_0(p_0))) = {\color{blue} {q_2}}$</li>
          <li>$w_{23} \sigma_2(w_{12} \sigma_1(w_{01} \sigma_0(p_0))) = {\color{blue} {p_3}}$</li>
          <li>$\sigma_3(w_{23} \sigma_2(w_{12} \sigma_1(w_{01} \sigma_0(p_0)))) = {\color{blue} {q_3}}$</li>
          <li>These are just the terms forward propagation generates.</li>
        </ul>
      </li>
      <li>Backward chains:
        <ul>
          <li>$(q_3-y)$</li>
          <li>$(q_3 - y) \sigma_3’(p_3)$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23}$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2)$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12}$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12} \sigma_1’(p_1)$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12} \sigma_1’(p_1) w_{01}$</li>
          <li>$(q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12} \sigma_1’(p_1) w_{01} \sigma_0’(p_0)$</li>
          <li>These now have derivatives and if $\sigma_i(x) = id(x)$, we can replace the derivatives by 1 and recover the backward chains from Case I.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>As before, let’s rewrite the derivatives with missing terms highlighted in ${\color{red} {red}}$.</p>

<p>$\frac{\partial C}{\partial w_{23}} = (q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))) {\color{red} {w_{23}}} \sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))$</p>

<p>$\frac{\partial C}{\partial w_{12}} = (q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))) w_{23} \sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0))) {\color{red} {w_{12}}} \sigma_1(w_{01}\sigma_0(p_0))$</p>

<p>$\frac{\partial C}{\partial w_{01}} = (q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))) w_{23} \sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0))) w_{12} \sigma_1’(w_{01}\sigma_0(p_0)) {\color{red} {w_{01}}} \sigma_0(p_0) $</p>

<p>Define new symbols for the backward chains:</p>

<p>$\delta_0 = (q_3-y) \sigma_3’(p_3)$</p>

<p>$\delta_1 = (q_3-y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) = {\color{green} {\delta_0 w_{23} \sigma’(p_2)}}$</p>

<p>$\delta_2 = (q_3-y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12} \sigma_1’(p_1) = {\color{ green} {\delta_1 w_{12} \sigma’(p_1)}}$</p>

<p>$\delta_3 = (q_3 - y) \sigma_3’(p_3) w_{23} \sigma_2’(p_2) w_{12} \sigma_1’(p_1) w_{01} \sigma_0’(p_0) = {\color{green} {\delta_2 w_{01} \sigma’(p_0)}}$</p>

<p>Using these, we can rewrite the derivatives:</p>

<p>$\frac{\partial C}{\partial w_{23}} = \underbrace{(q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0))))}_{\delta_0} \space {\color{red} {w_{23}}} \space \underbrace{\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))}_{q_2} = \delta_0 q_2$</p>

<p>$\frac{\partial C}{\partial w_{12}} = \underbrace{(q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))) w_{23} \sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))}_{\delta_1} \space {\color{red} {w_{12}}} \space \underbrace{\sigma_1(w_{01}\sigma_0(p_0))}_{q_1} = \delta_1 q_1$</p>

<p>$\frac{\partial C}{\partial w_{01}} = \underbrace{(q_3-y) \sigma_3’(w_{23}\sigma_2(w_{12}\sigma_1(w_{01}\sigma_0(p_0)))) w_{23} \sigma_2’(w_{12}\sigma_1(w_{01}\sigma_0(p_0))) w_{12} \sigma_1’(w_{01}\sigma_0(p_0))}_{\delta_2} \space {\color{red} {w_{01}}} \space \underbrace{q_0}_{q_0} = \delta_2 q_0$</p>

<p>As before, we get the same pattern:</p>

<p>$\frac{\partial C}{\partial w_{i,i+1}} = \delta_{2-i} q_i$</p>

<p>which is gratifying. As before, during the forward pass, we incrementally calculate $q_1, q_2, q_3$ and then we iteratively do a backward pass and calculate $\delta_0, \delta_1, \delta_2$.</p>

<h2 id="backpropagation-iii---linear-activations--multi-node-layers">Backpropagation III - linear activations + multi-node layers</h2>

<p>In practice, neural networks with one node per layer are not very helpful. What we really want is to put multiple nodes at each layer to get the classic feedforward neural network shown below. For now, as in Section I, we won’t include non-linear activations.</p>

<table class="image">
  <caption align="bottom">Fig 5. Multi-node linear feedforward network.</caption>
  <tr><td><img src="/assets/backprop/nn_3.svg" alt="Fig 5. Multi-node linear feedforward network." class="center" /></td></tr>
  <tr><td>&nbsp;</td></tr>
</table>

<p>Forward propagation in this architecture is:</p>

<p>$x_1 = W_{01} x_0$</p>

<p>$x_2 = W_{12} x_1$</p>

<p>$x_3 = W_{23} x_2$</p>

<p>where the $W_{ij}$ are matrices of weights. We used $w_{ij}$ to refer to an individual weight, like the ones in sections I and II and we’ll use $W_{ij}$ to refer to the <strong>weight matrix</strong> that takes us from layer $i$ to layer $j$. $x_i$ are now vectors and ideally should be written as $\vec{x}_i$ but we’ll omit the vector sign.</p>

<p>To be more explicit,</p>

<p>$x_0 = \begin{bmatrix}
x_1^{(0)} \\
x_2^{(0)} \\
\vdots \\
x_n^{(0)}
\end{bmatrix}$</p>

<p>and,</p>

<p>$W_{01} = \begin{bmatrix}
w_{11}^{(01)} &amp; w_{12}^{(01)} &amp; \ldots &amp; w_{1n}^{(01)} \\
w_{21}^{(01)} &amp; w_{22}^{(01)} &amp; \ldots &amp; w_{2n}^{(01)} \\
\vdots \\
w_{m1}^{(01)} &amp; w_{m2}^{(01)} &amp; \ldots &amp; w_{mn}^{(01)} \\
\end{bmatrix}$</p>

<p>and $x_1 = \underbrace{\begin{bmatrix}
x_1^{(1)} \\
x_2^{(1)} \\
\vdots \\
x_m^{(1)}
\end{bmatrix}}_{(m,1)}
= \underbrace{\begin{bmatrix}
w_{11}^{(01)} &amp; w_{12}^{(01)} &amp; \ldots &amp; w_{1n}^{(01)} \\
w_{21}^{(01)} &amp; w_{22}^{(01)} &amp; \ldots &amp; w_{2n}^{(01)} \\
\vdots \\
w_{m1}^{(01)} &amp; w_{m2}^{(01)} &amp; \ldots &amp; w_{mn}^{(01)} \\
\end{bmatrix}}_{(m,n)}
\underbrace{\begin{bmatrix}
x_1^{(0)} \\
x_2^{(0)} \\
\vdots \\
x_n^{(0)}
\end{bmatrix}}_{(n,1)}
=\underbrace{\begin{bmatrix}
w_{11}^{(01)} x_1^{(0)}  + w_{12}^{(01)} x_2^{(0)} + \ldots + w_{1n}^{(01)} x_n^{(0)} \\
w_{21}^{(01)} x_1^{(0)}  + w_{22}^{(01)} x_2^{(0)} + \ldots + w_{2n}^{(01)} x_n^{(0)} \\
\vdots \\
w_{m1}^{(01)} x_1^{(0)}  + w_{m2}^{(01)} x_2^{(0)} + \ldots + w_{mn}^{(01)} x_n^{(0)} \\
\end{bmatrix}}_{(m,1)}$</p>

<p>The superscripts denote the object a number belongs to. So, $x_{k}^{(0)}$ is the $k$th element of $x_0$ and $w_{ij}^{(01)}$ is the element in the $i$th row and $j$th column of $W_{01}$. The <strong>dimensions</strong> of the various objects are highlighted under the objects. $(m,n)$ means an object has $m$ rows and $n$ columns. We will often write $\text{dim}(A) = (m,n)$ to denote the dimension of object $A$.</p>

<p>We can combine these equations to write:</p>

<p>$x_3 = W_{23}W_{12}W_{01}x_0$</p>

<p>As in section I, there’s still the same silliness going on. Why not define $W_c = W_{23}W_{12}W_{01}$ which is just another matrix and do gradient descent on the elements of $W_c$ directly. As before though, we are preparing to introduce non-linear activations in the next section.</p>

<p>In principle, we haven’t done anything radically new. We just need to compute a cost and then find the derivatives with respect to each individual weight. Recall that we were using the mean-squared error metric as a cost function. The only difference is that now the output itself might be a vector:</p>

<p>$y = (y_1, y_2, \ldots, y_n)$</p>

<p>i.e. there are $n$ labels and the output vector $x_3$ also has $n$ dimensions. So the cost would just be a sum of mean-squared errors for every element in $y$ and $x_3$:</p>

<p>$C = \frac{1}{2} [(x_1^{(3)}-y_1)^2 + (x_{2}^{(3)}-y_2)^2 + \ldots + (x_{n}^{(3)}-y_n)^2]$</p>

<p>where $x_3 = (x_{1}^{(3)}, x_{2}^{(3)}, \ldots, x_{n}^{(3)})$</p>

<p>A more concise way of writing this is as follows:</p>

<p>$C[W_{01}, W_{12}, W_{23}] = \frac{(x_3-y)^T(x_3-y)}{2}$</p>

<p>where $x^T$ denotes the transpose of a vector. So,</p>

<p>$x = \begin{bmatrix} 
x_1 \\
x_2 \\
\vdots \\
x_n \end{bmatrix} \implies x^T = [x_1, x_2, \ldots, x_n]
$</p>

<p>More generally, given a matrix $A$ with elements $a_{ij}$, the transpose of a matrix, denoted by $A^T$ has elements where the rows and columns are flipped. So</p>

<p>$(A^T)_{ij} = a_{ji}$</p>

<p>Note that the indices on the right-hand side are flipped. An example will make this clear:</p>

<p>$A = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} \\
a_{21} &amp; a_{22} &amp; a_{23} \\
\end{bmatrix}
\implies
A^T = \begin{bmatrix}
a_{11} &amp; a_{21}\\
a_{12} &amp; a_{22}\\
a_{13} &amp; a_{23}\\
\end{bmatrix}
$</p>

<p>So, the $ij$-th element of $A^T$ is the $ji$-th element of A. In other words, $A^T$ takes every row of $A$ and makes it into a column. Moreover, transposing a matrix changes its dimensions. If $\text{dim}(A) = (m,n)$ then $\text{dim}(A^T) = (n,m)$.</p>

<p>Going back to the cost function:</p>

<p>$C = \frac{(x_3-y)^T(x_3-y)}{2} = \frac{1}{2} [x^{(3)}_1-y_1, x^{(3)}_2-y_2, \ldots, x^{(3)}_n-y_n] \begin{bmatrix}
x^{(3)}_1-y_1 \\
x^{(3)}_2-y_2 \\
\vdots \\
x^{(3)}_n-y_n \\
\end{bmatrix}$</p>

<p>$\implies C = \frac{1}{2} [(x_1^{(3)}-y_1)^2 + (x_{2}^{(3)}-y_2)^2 + \ldots + (x_{n}^{(3)}-y_n)^2]$</p>

<p>showing that the first form is just a more concise way of writing our original cost function.</p>

<p>Expanding, we get:</p>

<p>$C = \frac{(x_3-y)^T(x_3-y)}{2} = \frac{1}{2}[x_3^Tx_3 - x_3^Ty - y^Tx_3 + y^Ty]$</p>

<p>The only term that doesn’t depend on the weights matrices is $y^Ty$ and is a constant once the dataset is fixed (i.e. the labels are fixed). So we can neglect this term from here on since it’ll never contribute to our derivatives.</p>

<p>Also, $x_3^Ty = y^Tx_3$ since they are both just dot products between the same pair of vectors. More explicitly, if $x_3 = (a_1 a_2 \ldots a_n)$ and $y = (b_1 b_2 \ldots b_n)$, then</p>

<p>$x_3^Ty = [a_1 a_2 \ldots a_n]
\begin{bmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n
\end{bmatrix}
= a_1 b_1 + a_2 b_2 + \ldots a_n b_n$</p>

<p>and</p>

<p>$y^T x_3 = [b_1 b_2 \ldots b_n]
\begin{bmatrix}
a_1 \\
a_2 \\
\vdots \\
a_n
\end{bmatrix}
= b_1 a_1 + b_2 a_2 + \ldots b_n a_n$</p>

<p>The two values are the same.</p>

<p>So, we can rewrite the cost</p>

<script type="math/tex; mode=display">C[W] = \frac{1}{2}[x_3^Tx_3 - 2 y^Tx_3] = \frac{x_3^Ty}{2} - y^Tx_3 \label{multidimcost}</script>

<p>To reiterate:</p>
<ul>
  <li>”$=$” is being misused here since we completely dropped the term $y^Ty$ BUT since we are only using $C$ to find the derivatives for gradient descent and the dropped term doesn’t contribute, it doesn’t matter. If it makes you more comfortable, you could define a new cost $C’ = C - y^Ty$ and since minimizing a function $f$ is equivalent to minimizing $f + \text{constant}$, minimizing $C’$ and $C$ is equivalent in the sense that they will result in the same set of minimizing weights.</li>
  <li>We combined $x_3^Ty$ and $y^T x_3$ since they are equal (hence the factor of 2).</li>
</ul>

<p>Good progress! We are minimizing equation $\ref{multidimcost}$. We can compute the derivative with respect to every matrix element $w^{(ij)}_{ab}$ of every matrix $W_{ij}$ and do gradient descent on each one:</p>

<p>$w_{ab}^{(ij), (t+1)} = w_{ab}^{(ij), (t)} - \eta \frac{\partial C}{\partial w_{ab}^{(ij), (t+1)}}$</p>

<p>We are using the same notation as in sections I and II. In $w_{ab}^{(ij), (t+1)}$, the $t$ refers to the step in gradient descent, $(ij)$ refers to the matrix $W_{ij}$ that the weight comes from and $ab$ refers to the matrix element, i.e. row $a$ and column $b$. This horrible tragedy of notational burden is 1) very annoying, 2) absolutely devoid of any insight. Sure we can compute this mess and maybe even elegantly but unlike sections I and II, there seem to be no nice backward chains here. To prepare a nice meal, one has to sometimes do a lot of “prep” i.e. preparation of ingredients and “pre-processing” them. Using mathematics to understand and gain insights is no different. So we’ll take a nice de-tour to introduce the idea of <strong>matrix derivatives</strong>.</p>

<h3 id="aside-matrix-derivatives">Aside: Matrix derivatives</h3>

<p>Instead of writing the gradient descent update equation for each weight, we would like to write it for each weight matrix:</p>

<p>$W_{ij}^{(t+1)} = W_{ij}^{(t)} - \eta \frac{\delta C}{\delta W_{ij}^{(t)}}$</p>

<p>where we have introduced $\frac{\delta C}{\delta W_{ij}^{(t)}}$, the derivative of the cost with respect to a matrix! For the above equation to be well-defined, $\frac{\delta C}{\delta W_{ij}^{(t)}}$ would need to have dimensions of $W_{ij}$ and would be defined as:</p>

<p>$\frac{\delta C}{\delta W_{ij}} = \begin{bmatrix}
\frac{\partial C}{\partial w_{11}^{(ij)}} &amp; \frac{\partial C}{\partial w_{12}^{(ij)}} &amp; \ldots &amp; \frac{\partial C}{\partial w_{1n}^{(ij)}} \\
\frac{\partial C}{\partial w_{21}^{(ij)}} &amp; \frac{\partial C}{\partial w_{22}^{(ij)}} &amp; \ldots &amp; \frac{\partial C}{\partial w_{2n}^{(ij)}} \\
\vdots \\
\frac{\partial C}{\partial w_{m1}^{(ij)}} &amp; \frac{\partial C}{\partial w_{m2}^{(ij)}} &amp; \ldots &amp; \frac{\partial C}{\partial w_{mn}^{(ij)}} \\
\end{bmatrix}$</p>

<p>Our end goal is to deduce what rules such matrix derivatives would follow. To do so, we’ll have to get our hands dirty but only once. Once the rules are derived, we can forget all the details and blindly differentiate expressions with matrices.</p>

<p>Let’s start with one of the terms in the cost function.</p>

<h4 id="cost-linear-in-weights">Cost linear in weights</h4>

<p>Let’s start with a simple cost function:</p>

<p>$C[A] = y^TAx$</p>

<p>where $x, y$ are vectors and $A$ is a matrix. More precisely,</p>

<p>$\text{dim}(x) = (n,1)$</p>

<p>$\text{dim}(A) = (m,n)$</p>

<p>$\text{dim}(y) = (m,1)$</p>

<p>Why are the dimensions important? Because the product $O_1O_2$ is only defined when</p>

<p>$\text{number of columns of } O_1 = \text{number of rows of } O_2$</p>

<p>and the dimensions of $O_1O_2$ will be:</p>

<p>$(\text{number of rows of }O_1, \text{number of columns of }O_2)$</p>

<p>A more concise way of writing this is:</p>

<p>$\text{dim}(O_1) = (n_1, k)$</p>

<p>$\text{dim}(O_2) = (k, m_2)$</p>

<p>$\implies \text{dim}(O_1O_2) = (n_1, m_2)$</p>

<p>For our case,</p>

<p>$C[A] = \underbrace{y^T}_{(1,m)}\underbrace{A}_{(m,n)}\underbrace{x}_{(n,1)}$</p>

<p>and $\text{dim}(C[A]) = (1,1)$ i.e. it’s just a number which is what we expected to get for the cost.</p>

<p>Our notation for the cost:</p>

<p>$C[A]$</p>

<p>betrays our intention to keep $x, y$ fixed and minimize $C$ as a function of the elements of $A$. We will still use gradient descent which requires that we compute the derivatives of $C$ with respect to the elements of $A$.</p>

<p>$A = \begin{bmatrix}
	a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1n} \\
	a_{21} &amp; a_{22} &amp; \ldots &amp; a_{2n} \\
	\vdots \\
	a_{m1} &amp; a_{m2} &amp; \ldots &amp; a_{mn} \\
\end{bmatrix}$</p>

<p>Once we have the derivatives:</p>

<p>$\frac{\partial C}{\partial a_{ij}}$</p>

<p>we can update the elements of $A$:</p>

<p>$a_{ij}^{(t+1)} = a_{ij}^{(t)} - \eta \frac{\partial C}{\partial a_{ij}^{(t)}}$</p>

<p>Instead let’s combine the derivatives in a matrix:</p>

<p>$\frac{\delta C}{\delta A} \equiv \begin{bmatrix}
	\frac{\partial C}{\partial a_{11}} &amp; \frac{\partial C}{\partial a_{12}} &amp; \ldots &amp; \frac{\partial C}{a_{1n}} \\
	\frac{\partial C}{\partial a_{21}} &amp; \frac{\partial C}{\partial a_{22}} &amp; \ldots &amp; \frac{\partial C}{a_{2n}} \\
	\vdots \\
	\frac{\partial C}{\partial a_{m1}} &amp; \frac{\partial C}{\partial a_{m2}} &amp; \ldots &amp; \frac{\partial C}{a_{mn}} \\
\end{bmatrix}$</p>

<p>where $\text{dim}(A) = \text{dim}(\frac{\delta C}{\delta A}) = (m,n)$</p>

<p>We can then write:</p>

<p>$A^{(t+1)} = A^{(t)} - \eta \frac{\delta C}{\delta A^{(t)}}$</p>

<p>i.e. update the whole matrix in one go! Please note that the superscript $t$ is for the time-step NOT tranpose. For tranpose, we always use a <em>capital</em> T.</p>

<p>We also know that $C$ is linear in the elements of $A$ (more on this below) and so the derivatives should not depend on $A$ - just like the derivative of the linear function, $f(x) = ax + b$ with respect to x, $\frac{df}{dx} = a$ doesn’t depend on $x$. So, $\frac{\delta C}{\delta A}$ can only depend on $x,y$ and the only way to construct a matrix of dimension $(m,n)$ from $x$ and $y$ is</p>

<p>$\underbrace{y}_{(m,1)}\underbrace{x^T}_{(1,n)} = \begin{bmatrix}
y_1 \\
y_2 \\
\vdots \\
y_m
\end{bmatrix}
\begin{bmatrix}
x_1 &amp; x_2 &amp; \ldots &amp; x_n \\
\end{bmatrix} = \begin{bmatrix}
y_1 x_1 &amp; y_1 x_2 &amp; \ldots y_1 x_n \\
y_2 x_1 &amp; y_2 x_2 &amp; \ldots y_2 x_n \\
\vdots \\
y_m x_1 &amp; y_m x_2 &amp; \ldots y_md x_n \\
\end{bmatrix}$</p>

<p>Maybe all this is just too general and hand-wavy. After all, couldn’t we multiply $yx^T$ by a constant and still get something with dimension $(m,n)$. That’s true! So, let’s compute the derivative matrix explicitly to convince ourselves.</p>

<p>$C[A] = \begin{bmatrix}
	y_1 &amp; y_2 &amp; \ldots &amp; y_m \\
\end{bmatrix}
\begin{bmatrix}
	a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1n} \\
	a_{21} &amp; a_{22} &amp; \ldots &amp; a_{2n} \\
	\vdots \\
	a_{m1} &amp; a_{m2} &amp; \ldots &amp; a_{mn} \\
\end{bmatrix}
\begin{bmatrix}
	x_1 \\
	x_2 \\
	\vdots \\
	x_n
\end{bmatrix}$</p>

<p>$C[A] = \begin{bmatrix}
	y_1 &amp; y_2 &amp; \ldots &amp; y_m \\
\end{bmatrix}
\begin{bmatrix}
	a_{11} x_1 + a_{12} x_2 + \ldots + a_{1n} x_n \\
	a_{21} x_1 + a_{22} x_2 + \ldots + a_{2n} x_n \\
	\ldots \\
	a_{m1} x_1 + a_{m2} x_2 + \ldots + a_{mn} x_n \\
\end{bmatrix} \\ = (y_1 a_{11} x_1 + y_1 a_{12} x_2 + \ldots y_1 a_{1n} x_n) + (y_2 a_{21} x_1 + y_2 a_{22} x_2 + \ldots y_2 a_{2n} x_n) + \ldots + (y_m a_{m1} x_1 + y_m a_{m2} x_2 + \ldots y_m a_{mn} x_n)$</p>

<p>If we look closely at the last line, all the terms are of the form $y_i a_{ij} x_j$ (which is exactly how one writes matrix multiplication). So, we could write this as:</p>

<p>$C[A] = \Sigma_{i=1}^{m}\Sigma_{j=1}^{n} y_i a_{ij} x_j$</p>

<p>We also introduce the so-called Einstein (yes, the same Einstein you are thinking about) notation here now. We drop the summation sign, $\Sigma$ and write:</p>

<p>$C[A] = y_i a_{ij} x_j$</p>

<p>with the convention that any index that repeats twice is to be summed over. Since i appears twice - once with $y$ and once in $a_{ij}$ and j appears twice - once with $a_{ij}$ and once with $x_j$, they both get summed over the appropriate range. This way we don’t have to write the summation sign each way.</p>

<p>To be clear, $y_i a_{ij} x_j$ is the same as $\Sigma_{i=1}^{m}\Sigma_{j=1}^{n} y_i a_{ij} x_j$ using the Einstein notation. Also, it doesn’t matter what we call the repeated index so:</p>

<p>$y_i a_{ij} x_j = y_{bob} a_{bob,nancy} x_{nancy}$</p>

<p>It doesn’t matter at all what we can the indices. All that matters is that repeated indices get summed over.</p>

<p>Great! so we computed an explicit form of $C$ and now we want derivatives with respect to $a_{kl}$ where $k,l$ are just indices denoting row k and column l.</p>

<p>$\frac{\partial C}{\partial a_{kl}} = \frac{\partial}{\partial a_{kl}} [y_i a_{ij} x_j]$</p>

<p>We define:</p>

<p>$\delta_{a,b} = \begin{cases}
1, \text{if } a=b \\
0, \text{otherwise} \\
\end{cases}$</p>

<p>Then,</p>

<p>$\frac{\partial C}{\partial a_{kl}} = y_i x_j \frac{\partial a_{ij}}{\partial a_{kl}}$</p>

<p>since $y_i, x_j$ don’t depend on $a_{kl}$.</p>

<p>Now,</p>

<p>$\frac{\partial a_{ij}}{\partial a_{kl}} = \begin{cases}
1, \text{if } i=k, j=l \\
0, \text{otherwise}
\end{cases}$</p>

<p>Another way of writing this is:</p>

<p>$\frac{\partial a_{ij}}{\partial a_{kl}} = \delta_{i,k}\delta_{j,l}$</p>

<p>So,</p>

<p>$\frac{\partial C}{\partial a_{kl}} = y_i x_j \frac{\partial a_{ij}}{\partial a_{kl}} = y_i x_j \delta_{i,k}\delta_{j,l}$</p>

<p>But since repeated indices are summed over, when $i=k$ and when $j=l$, we get:</p>

<p>$\frac{\partial C}{\partial a_{kl}} = y_k x_l$</p>

<p>which is exactly the $(k,l)$ element of $yx^T$. So we just showed through explicit calculation that:</p>

<script type="math/tex; mode=display">\boxed{C = y^T A x \implies \frac{\delta C}{\delta A} = y x^T}</script>

<p>the same result we got earlier by looking at various dimensions.</p>

<p>This can be used in gradient descent as:</p>

<p>$A^{(t+1)} = A^{(t)} - \eta \frac{\delta C}{\delta A^{(t)}} = A^{(t)} - \eta y x^T$</p>

<p>Now (anticipating future use), what if</p>

<p>$C[A, B] = y^T A B x$</p>

<p>is our cost function. Is there an easy way to calculate $\frac{\delta C}{\delta A}$ and $\frac{\delta C}{\delta B}$? You bet there is!</p>

<p>Let’s start with $\frac{\delta C}{\delta A}$.</p>

<p>We can define $x’ = Bx$ to get $C = y^T A x’$:</p>

<p>$C = y^T A \underbrace{B x}_{x’} = y^T A x’$</p>

<p>We know $\frac{\delta C}{\delta A} = y x’^T$ from our earlier result and we can just replace $x’$ to get:</p>

<p>$\frac{\delta C}{\delta A} = y x’^T = y (Bx)^T = y x^T B^T$ using the fact $(AB)^T = B^TA^T$.</p>

<p>On to $\frac{\delta C}{\delta B}$. We can use a similar trick.</p>

<p>$C = y^T A B x = (A^Ty)^T B x$ since $(A^Ty)^T = y^T A$</p>

<p>Let’s define $y’ = A^T y$:</p>

<p>$C = {\underbrace{(A^Ty)}_{y’}}^T B x = y’^T B x$</p>

<p>From our previous result:</p>

<p>$\frac{\delta C}{\delta B} = y’ x^T = A^T y x^T$</p>

<p>To summarize:</p>

<script type="math/tex; mode=display">\boxed{C = y^T A B x \implies \frac{\delta C}{\delta A}=y x^T B^T, \frac{\delta C}{\delta B} = A^T y x^T}</script>

<h4 id="cost-quadratic-in-weights">Cost quadratic in weights</h4>

<p>The other term in our neural network cost function is a quadratic cost function:</p>

<p>$C = \frac{1}{2} x^TA^TAx$</p>

<p>We have two $A$ matrices multiplying the terms hence it’s quadratic in the weights/elements of $A$.</p>

<p>The dimensions are:</p>

<p>$\text{dim}(x) = (n,1) \implies dim(x^T) = (1,n)$</p>

<p>$\text{dim}(A) = (m,n) \implies dim(A^T) = (n,m)$</p>

<p>Can we still guess what $\frac{\delta C}{\delta A}$ should be from the dimensions alone?</p>

<p>We expect $\text{dim}(A) = \text{dim}(\frac{\delta C}{\delta A}) = (m,n)$ and also since $C$ is quadratic in $A$, we expect the derivative to be linear in $A$.</p>

<p>Let’s take a few guesses:</p>

<p>$\frac{\delta C}{\delta A} = A (x^Tx)$ which works dimensionally since $x^Tx$ is just a number.</p>

<p>$\frac{\delta C}{\delta A} = A (xx^T)$ which works dimensionally since $xx^T$ has dimension $(n,n)$ so we still get something linear in $A$ and with dimension $(m,n)$.</p>

<p>Technically, $\frac{\delta C}{\delta A} = A (xx^T) (xx^T)$ also works. But if we follow our intuition from calculus, $C$ is quadratic in $x$ and the $x$ terms just come along for the ride as constants. Taking derivatives can’t change its order. So the final answer also needs to be quadratic in $x$ which rules out $A (xx^T) (xx^T)$ or $A (xx^T)^n$ for $n&gt;1$.</p>

<p>Let’s see if we can convince ourselves by doing an explicit calculation. We’ll happly use our new index notation to cut through the calculation:</p>

<p>$C = \frac{1}{2} x^TA^TAx = \frac{1}{2} x_i (A^T)_{ij} (A)_{jk} x_k = \frac{1}{2} x_i a_{ji} a_{jk} x_k$</p>

<p>where as before repeated indices mean an implicit sum. Now, using the chain rule:</p>

<p>$\frac{\partial C}{\partial a_{cd}} = \frac{1}{2} [x_i \frac{\partial a_{ji}}{\partial a_{cd}} a_{jk} x_k + x_i a_{ji} \frac{\partial a_{jk}}{\partial a_{cd}} x_k]$</p>

<p>$\frac{\partial C}{\partial a_{cd}} = \frac{1}{2} [x_i \delta_{j,c}\delta_{i,d} a_{jk} x_k + x_i a_{ji} \delta_{j,c}\delta_{k,d} x_k] = \frac{1}{2} [x_d a_{ck} x_k + x_i a_{ci}x_d]$</p>

<p>These two terms are exactly the same:</p>

<p>$x_d a_{ck} x_k = x_d (Ax)_{c}$</p>

<p>$x_i a_{ci} x_d = x_d a_{ci} x_i = x_d (Ax)_{c}$</p>

<p>and add up to kill the factor of $\frac{1}{2}$.</p>

<p>So,</p>

<p>$\frac{\partial C}{\partial a_{cd}} = (Ax)_{c} x_d = (Axx^T)_{cd}$</p>

<p>In other words, we just showed that:</p>

<script type="math/tex; mode=display">\boxed{C = \frac{1}{2}x^TA^TAx \implies \frac{\delta C}{\delta A} = Ax x^T}</script>

<p>We still have one more calculation to do that will be crucial for doing back-propagation on our multi-node neural network.</p>

<p>Suppose,</p>

<p>$C = \frac{1}{2} x^T B^T A^T A B x$</p>

<p>Calculating $\frac{\delta C}{\delta A}$ is easy given what we just calculated and we just need to replace $x \rightarrow B x$. So,</p>

<p>$\frac{\delta C}{\delta A} = (ABx) (Bx)^T = (ABx)x^TB^T$</p>

<p>But what about $\frac{\delta C}{\delta B}$? $B$ is sandwiched between $A$ and $x$ and can’t be factored away. If we define $D = A^T A$ then we have</p>

<p>$C = \frac{1}{2} x^T B^T D B x$</p>

<p>Again we’ll guess our solution base on dimensions and then explicitly compute it.</p>

<p>We are given the sizes:</p>

<p>$\text{dim}(x) = (n,1) \implies dim(x^T) = (1,n)$</p>

<p>$\text{dim}(B) = (m, n) \implies dim(B^T) = (n, m)$</p>

<p>$\text{dim}(A) = (l, m) \implies dim(A^T) = (m,l)$</p>

<p>We also expect $\text{dim}(\frac{\delta C}{\delta B}) = \text{dim}(B) = (m,n)$. As before, the derivative should be linear in $B$, quadratic in $A$ and $x$ since they are for all practical purposes, constants for us.</p>

<p>So, let’s see what modular pieces we have to work with:</p>

<p>Quadratic in $x$:</p>

<p>$\text{dim}(x^Tx) = (1,1)$</p>

<p>$\text{dim}(xx^T) = (n,n)$</p>

<p>Quadratic in $A$:</p>

<p>$\text{dim}(A A^T) = (l,l)$</p>

<p>$\text{dim}(A^T A) = (m,m)$</p>

<p>Linear in $B$:</p>

<p>$\text{dim}(B) = (m,n)$</p>

<p>So we can multiply $B$ on the right by something that is $(1,1)$ i.e. $x^Tx$ or $(n,n)$ i.e. $xx^T$ and on the left by something that is $(m,m)$ i.e. $A^TA$ and still maintain the dimensionality of $B$.</p>

<p>Our guess is:</p>

<p>$\frac{\delta C}{\delta B} = (A^T A) B \begin{cases} 
xx^T \\
x^Tx \\
\end{cases}$</p>

<p>We also know that if we replace $D = A^T A$ by the $(m,m)$ identity matrix, we recover our previous example $C = \frac{1}{2} x^T B^T B x$ which gave us $\frac{\delta C}{\delta B} = B (xx^T)$ so we know $xx^T$ is the wrong choice to make.</p>

<p>To summarize:</p>

<script type="math/tex; mode=display">\boxed{C = \frac{1}{2} x^T B^T A^T A B x \implies \frac{\delta C}{\delta A} = (ABx) (Bx)^T, \frac{\delta C}{\delta B} = (A^T A) B (xx^T)}</script>

<p>Of course, let’s prove this by doing the explicit calculation using our powerful index notation:</p>

<p>We defined $D = A^TA$ which is a symmetric matrix i.e. $D^T = (A^TA)^T = A^T A = D$ or in terms of elements of $D$, $d_{ij} = d_{ji}$.</p>

<p>$C = \frac{1}{2} x^T B^T D B x = \frac{1}{2} x_i (B^T)_{ij} (D)_{jk} (B)_{kl} x_l = \frac{1}{2} x_i b_{ji} d_{jk} b_{kl} x_l$</p>

<p>Then,</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = \frac{1}{2} [x_i \frac{\partial b_{ji}}{\partial b_{cd}} d_{jk} b_{kl} x_l + x_i b_{ji} d_{jk} \frac{\partial b_{kl}}{\partial b_{cd}} x_l]$</p>

<p>The derivatives above can only be $1$ when the indices match and otherwise they are $0$:</p>

<p>$\frac{\partial b_{kl}}{\partial b_{cd}} = \delta_{k,c} \delta_{l,d}$</p>

<p>So,</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = \frac{1}{2} [x_i \delta_{j,c}\delta_{i,d} d_{jk} b_{kl} x_l + x_i b_{ji} d_{jk} \delta_{k,c}\delta_{l,d} x_l]$</p>

<p>All repeated indices are summed over and the $\delta$s pick out the correct index. As an example:</p>

<p>$\delta_{a,b} x_b = \Sigma_{b=0}^{n} \delta_{a,b} x_b = \underbrace{\Sigma_{b\neq a} \underbrace{\delta_{a,b}}_{= 0} x_b + \underbrace{\delta_{a,a}}_{= 1} x_a}_{\text{Separating terms where the index is a and not a}} = x_a$</p>

<p>In other words if you see</p>

<p>$\delta_{a,b} x_b$</p>

<p>read it as “wherever you see a $b$, replace it with an $a$ and remove the deltas”</p>

<p>and if you see</p>

<p>$\delta(a,b)\delta(c,d) x_b y_d$</p>

<p>read it as “wherever you see a $b$, replace it with $a$ and wherever you see $d$, replace it with $c$ and remove the deltas”.</p>

<p>Using this, we get</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = \frac{1}{2} [x_d d_{ck} b_{kl} x_l + x_i b_{ji} d_{jc} x_d]$</p>

<p>These are basically the same terms:</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = \frac{1}{2} x_d [d_{ck} b_{kl} x_l + d_{jc} b_{ji} x_i]$</p>

<p>where we have just rearranged the factors in the second term and factored out $x_d$. Recall that $D$ was symmetric, i.e. $d_{jc} = d_{cj}$. Then we get</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = \frac{1}{2} x_d [d_{ck} b_{kl} x_l + d_{cj} b_{ji} x_i]$</p>

<p>So the two terms are exactly the same since the only non-repeated index is $c$. In other words</p>

<p>$[\frac{\delta C}{\delta B}]_{cd} = x_d d_{ck} b_{kl} x_l = (DBx)_{c}x_d = (DBxx^T)_{cd}$</p>

<p>confirming our suspicion that:</p>

<p>$\frac{\delta C}{\delta B}] = (DBxx^T) = (A^TA)B(xx^T)$</p>

<p>That’s it! I promise that’s the end of index manipulation exercises for this section. We’ll now collect all our results and use them to show that we still get backward chains as before.</p>

<script type="math/tex; mode=display">\boxed{C = y^TAx \implies \frac{\delta C}{\delta A} = yx^T}\label{linearnoactA}</script>

<script type="math/tex; mode=display">\boxed{C = y^TABx \implies \frac{\delta C}{\delta A} = yx^TB^T, \frac{\delta C}{\delta B} = A^Tyx^T}\label{linearnoactAB}</script>

<script type="math/tex; mode=display">\boxed{C = \frac{1}{2} x^TA^TAx \implies \frac{\delta C}{\delta A} = A(xx^T)}\label{quadraticnoactA}</script>

<script type="math/tex; mode=display">\boxed{C = \frac{1}{2} x^TB^TA^TABx \implies \frac{\delta C}{\delta A} = AB(xx^T)B^T, \frac{\delta C}{\delta B} = (A^TA) B (xx^T)}\label{quadraticnoactAB}</script>

<p>At this stage, we could declare victory because we have learned how to differentiate expression that occur in the cost for the feedforward neural network without worrying about indices. But, what we really want is rules that we can understand easily. We care mostly about equations $\ref{linearnoactAB}$ and $\ref{quadraticnoactAB}$. Why? Because generally our neural networks will have multiple layers with a matrix ($A, B$) for each layer-to-layer transition.</p>

<p>Let’s focus on equation $\ref{linearnoactAB}$:</p>

<p><script type="math/tex">C = y^TABx \implies \frac{\delta C}{\delta A} = yx^TB^T, \frac{\delta C}{\delta B} = A^Tyx^T</script> and on the $\frac{\delta C}{\delta A}$ term first.</p>

<p>$\frac{\delta C}{\delta A} = \frac{\delta}{\delta A}(y^TABx) = \frac{\delta}{\delta A} (\underbrace{y^T}_{\text{constant with respect to A}} A \underbrace{Bx}_{\text{constant with respect to A}}) = yx^TB^T = (y^T)^T (Bx)^T$</p>

<p>Now, if we were dealing with usual derivatives ($a,b$ are constants below):</p>

<p>$\frac{d(a x b)}{dx} = \frac{d}{dx} (\underbrace{a}_{\text{constant with respect to x}} x \underbrace{b}_{\text{constant with respect to x}}) = a b$</p>

<p>So, the derivative $\frac{d}{dx}$ simply let’s $a$ and $b$ pass through.</p>

<p>But it seems for our matrix derivative, the constants $y^T$ and $Bx$ pass through after being transposed. In other words, the derivative $\frac{\delta}{\delta A}$ will transpose any constant vector to give:</p>

<p>$\frac{\delta}{\delta A}(y^TABx) = (y^T)^T \frac{\delta}{\delta A}(A Bx) = y \underbrace{\frac{\delta A}{\delta A}}_{=1} (Bx)^T = y (Bx)^T = yx^TB^T$</p>

<p>Also, note that unlike regular numbers where we can re-order the terms, $ab = ba$, this is generally not true for vectors and matrices $AB \neq BA$ and is sometimes not even defined given $\text{dim}(A)$ and $\text{dim}(B)$.</p>

<p>We haven’t proven this rules works in general so let’s see if it works for $\frac{\delta C}{\delta B}$. If we transposed and passed through every constant vector and matrix, we would get:</p>

<p>$\frac{\delta C}{\delta B} = \frac{\delta}{\delta B}(y^TABx) = (y^TA)^T\frac{\delta B}{\delta B}x^T = A^Tyx^T$ which is exactly what $\ref{linearnoactAB}$ says!</p>

<p>So the central rules seems to be:</p>

<ul>
  <li>To differentiate an expression linear in the matrix we want to differentiate with respect to, pass through all constants but transpose them.</li>
</ul>

<p>We haven’t proven this rule works in general but we’ll constantly test this intuition.</p>
<h3 id="end-of-aside-on-matrix-derivatives">End of Aside on Matrix derivatives</h3>

<p>It’s time to get back to our neural network and put all this together. To recap, our forward propagation was defined as:</p>

<p>$x_1 = W_{01} x_0$</p>

<p>$x_2 = W_{12} x_1$</p>

<p>$x_3 = W_{23} x_2$</p>

<p>or if we combine the equations:</p>

<p>$x_3 = W_{23}W_{12}W_{01}x_0$</p>

<p>and the cost is:</p>

<script type="math/tex; mode=display">C[W_{01}, W_{12}, W_{23}] = \frac{1}{2}[x_3^Tx_3 - 2 y^Tx_3] = \frac{x_3^Tx_3}{2} - y^Tx_3</script>

<p>Plugging in the expression for $x_3$, we get</p>

<script type="math/tex; mode=display">C[W_{01}, W_{12}, W_{23}] = \frac{1}{2}x_0^TW_{01}^TW_{12}^TW_{23}^TW_{23}W_{12}W_{01}x_0 - y^TW_{23}W_{12}W_{01}x_0</script>

<p>We can now use our catalog of matrix derivatives to calculate the 3 derivatives needed for gradient descent: $\frac{\delta C}{\delta W_{01}}, \frac{\delta C}{\delta W_{12}}, \frac{\delta C}{\delta W_{23}}$</p>

<p>$\frac{\delta C}{\delta W_{01}}$:</p>

<p>Let’s define $D \equiv W_{23}W_{12}$ to get:</p>

<p>$C = \frac{1}{2}x_0^TW_{01}^T\underbrace{W_{12}^TW_{23}^T}_{D^T}\underbrace{W_{23}W_{12}}_{D}W_{01}x_0 - y^T\underbrace{W_{23}W_{12}}_{D}W_{01}x_0$</p>

<p>$C = \frac{1}{2} x_0^T W_{01}^T D^T D W_{01} x_0 - y^T D W_{01} x_0$</p>

<p>Then, using identities $\ref{quadraticnoactAB}$ AND $\ref{linearnoactAB}$:</p>

<p>$\frac{\delta C}{\delta W_{01}} = \frac{\delta}{\delta W_{01}} \frac{1}{2} x_0^T W_{01}^T D^T D W_{01} x_0 - \frac{\delta}{\delta W_{01}} y^T D W_{01} x_0 = (D^TD)W_{01}(x_0x_0^T) - D^T y x_0^T$</p>

<p>So,</p>

<p>$\frac{\delta C}{\delta W_{01}} = W_{12}^TW_{23}^T(W_{23}W_{12}W_{01}x_0)x_0^T - W_{12}^TW_{23}^Tyx_0^T$</p>

<p>But, $W_{23}W_{12}W_{01}x_0$ is precisely $x_3$, the result of forward propagation. So, we get a very nice result:</p>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta W_{01}} = W_{12}^TW_{23}^T(x_3-y)x_0^T}</script>

<p>Note that the combination $x_3-y$ shows up again and if the prediction is exactly correct i.e. if $x_3 = y$, then the derivative is 0 and there’s no correction via gradient descent, as one would expect.</p>

<p>$\frac{\delta C}{\delta W_{12}}$:</p>

<p>Define $u \equiv W_{01}x_0$ to get:</p>

<p>$C = \frac{1}{2} \underbrace{x_0^TW_{01}^T}_{u^T} W_{12}^TW_{23}^TW_{23}W_{12} \underbrace{W_{01}x_0}_{u} - y^TW_{23}W_{12}\underbrace{W_{01}x_0}_{u}$</p>

<p>$C = \frac{1}{2}u^TW_{12}^TW_{23}^TW_{23}W_{12}u - y^TW_{23}W_{12}u$</p>

<p>Using identities $\ref{quadraticnoactAB}$ AND $\ref{linearnoactAB}$, we get:</p>

<p>$\frac{\delta C}{\delta W_{01}} = W_{23}^TW_{23}W_{12}uu^T - W_{23}^Tyu^T$</p>

<p>Replacing $u = W_{01}x_0$,</p>

<script type="math/tex; mode=display">\frac{\delta C}{\delta W_{12}} = W_{23}^TW_{23}W_{12}W_{01}x_0x_0^TW_{01}^T - W_{23}^Tyx_0^TW_{01}^T = W_{23}^Tx_3x_1^T - W_{23}^Tyx_1^T = W_{23}^T(x_3-y)x_1^T</script>

<p>So,</p>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta W_{12}} = W_{23}^T(x_3-y)x_1^T}</script>

<p>$\frac{\delta C}{\delta W_{23}}$:</p>

<p>Define $D \equiv W_{12}W_{01}$ to get:</p>

<p>$C = \frac{1}{2}x_0^T \underbrace{W_{01}^TW_{12}^T}_{D^T} W_{23}^TW_{23}\underbrace{W_{12}W_{01}}_{D}x_0 - y^TW_{23} \underbrace{W_{12}W_{01}}_{D} x_0$</p>

<p>$C = \frac{1}{2}x_0^TD^TW_{23}^TW_{23}Dx_0 - y^TW_{23}Dx_0$</p>

<p>Using identities $\ref{quadraticnoactAB}$ AND $\ref{linearnoactAB}$, we get:</p>

<p>$\frac{\delta C}{\delta W_{23}} = W_{23}D(x_0x_0^T)D^T - y^Tx_0^TD^T$</p>

<p>Replacing $D = W_{12}W_{01}$:</p>

<p>$\frac{\delta C}{\delta W_{23}} = W_{23}W_{12}W_{01}x_0x_0^TW_{01}^TW_{12}^T - y^Tx_0^TW_{01}^TW_{12}^T = (x_3-y)x_2^T$</p>

<p>In summary:</p>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta W_{01}} = W_{12}^TW_{23}^T(x_3-y)x_0^T}</script>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta W_{12}} = W_{23}^T(x_3-y)x_1^T}</script>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta W_{23}} = (x_3-y)x_2^T}</script>

<p>Presto!!! We again see forward and backward chains.</p>

<p>Forward chains:</p>
<ul>
  <li>${\color{blue} x_0}$</li>
  <li>$W_{01} x_0 = {\color{blue} x_1}$</li>
  <li>$W_{12} W_{01} x_0 = {\color{blue} x_2}$</li>
  <li>$W_{23} W_{12} W_{01} x_0 = {\color{blue} x_3}$</li>
</ul>

<p>Backward chains:</p>
<ul>
  <li>$x_3-y \equiv {\color{red} {\Delta_0}}$</li>
  <li>$W_{23}^T(x_3-y) \equiv {\color{red} {\Delta_1}}$</li>
  <li>$W_{12}^TW_{23}^T(x_3-y) \equiv {\color{red} {\Delta_2}}$</li>
  <li>$W_{01}^TW_{12}^TW_{23}^T(x_3-y) \equiv {\color{red} {\Delta_3}}$</li>
</ul>

<p>where we now use capital deltas $\Delta$ instead of small deltas $\delta$, to signify that the backward chains are matrices.</p>

<p>As before, we can succinctly write the derivatives as:</p>

<p>$\frac{\delta C}{\delta W_{i,i+1}} = \Delta_{2-i} x_i^T$</p>

<p>In this notation, this is essentially the same as the results from sections I and II except for the fact that $x_i$ is now a vector and $\Delta_i$ is a matrix.</p>

<h2 id="backpropagation-iv-in-progress--non-linear-activations--multi-node-layers">Backpropagation IV (In Progress)- non-linear activations + multi-node layers</h2>

<p>Finally, the action begins! We can now start building up the full backpropagation for a realistic feedforward neural network with multiple layers, each with multiple nodes and non-linear activations.</p>

<p>We’ll use notation similar to section II.</p>

<p>Forward propagation is:</p>

<p>$\begin{array}{ccc}
p_0 = x_0 &amp; q_0 = \sigma_0(x_0) \\
p_1 = W_{01} q_0 &amp; q_1 = \sigma_1(p_1) \\
p_2 = W_{12} q_1 &amp; q_2 = \sigma_2(p_2) \\
p_3 = W_{23} q_2 &amp; q_3 = \sigma_3(p_3) \\
\end{array}$</p>

<p>where $W_{ij}$ are matrices and $p_i, q_i$ are vectors and all the dimensions are such that matrix multiplications are well-defined. $\sigma_i$ are activation functions and they act on vectors element-wise:</p>

<p>$\sigma \begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix}
= \begin{bmatrix}
\sigma(x_1) \\
\sigma(x_2) \\
\vdots \\
\sigma(x_n) \\
\end{bmatrix}$</p>

<p>To summarize:</p>
<ul>
  <li>$p_i$ and $q_i$ are always vectors.</li>
  <li>$p_i$ is the “pre-activation” (“p” for “pre”) input to a layer.</li>
  <li>$q_i$ is the “post-activation” (“q” since it comes after “p”) output of a layer.</li>
  <li>$W_{ij}$ is a matrix that always takes $q_i \rightarrow p_j$.</li>
  <li>$\sigma_i$ always takes $p_i \rightarrow q_i$.</li>
</ul>

<p>The last two rules pop out of our equations and while it’s just notation, it serves as a powerful guide to ensure that we are not making mistakes. At any point in the calculation if you see the combination $W_{ij} p_i$, something is probably wrong. If we see $W_{ij}p_k$ where $k\neq i,j$, something is probably wrong.</p>

<p>As before, we’ll use the mean-squared cost which is:</p>

<p>$C[W_{01}, W_{12}, W_{23}] = \frac{1}{2} (q_3-y)^2$</p>

<p>For the purposes of optimization, we can expand:</p>

<p>$C = \frac{1}{2} (q_3^Tq_3 - 2y^Tq_3)$</p>

<p>so we get a term quadratic in $q_3$ ($\frac{1}{2} q_3^Tq_3$) and a term linear in $q_3$ ($y^Tq_3$). As in section III, we drop the constant (independent of $q_3$ and thus the weights) term $\frac{1}{2} y^Ty$.</p>

<p>If we combined all the forward propagation equations, we get:</p>

<p>$q_3 = \sigma_3(W_{23}\sigma_2(W_{12}\sigma_1(W_{01}\sigma_0(p_0))))$</p>

<p>We need matrix derivatives but with a twist introduced by the activation functions. Since we already had some practice in Section III, let’s dive straight in:</p>

<h3 id="aside-matrix-derivatives-1">Aside: Matrix derivatives</h3>

<h4 id="cost-linear-in-weights-1">Cost linear in weights</h4>

<p>Let’s start with a simpler cost that mimics the term linear in $q_3$:</p>

<p>$C[A] = y^T \sigma(A x)$</p>

<p>where the dimensions are:</p>

<p>$\text{dim}(x) = (n,1)$</p>

<p>$\text{dim}(y) = (m,1)$</p>

<p>$\text{dim}(A) = (m,n)$</p>

<p>In other words:</p>

<p>$C[A] = \underbrace{y^T}_{(1,m)} \sigma(\underbrace{A}_{(m,n)} \underbrace{x}_{(n,1)})$</p>

<p>We want to compute $\frac{\delta C}{\delta A}$.</p>

<p>We can try guessing what this should be based on the dimensions of the matrix.</p>

<ul>
  <li>$\frac{\delta C}{\delta A}$ should be linear in $x$ and $y$</li>
  <li>It should also depend on $\sigma’(Ax)$ where</li>
</ul>

<p>$\sigma’(Ax) = \sigma’\begin{bmatrix}
a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n \\
a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n \\
\vdots \\
a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n \\
\end{bmatrix}
=\begin{bmatrix}
\sigma’(a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n) \\
\sigma’(a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n) \\
\vdots \\
\sigma’(a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n) \\
\end{bmatrix}$
with $\sigma’(x)$ denoting $\frac{d\sigma}{dx}$ ns a more compact notation.</p>
<ul>
  <li>
    <p>$\text{dim}(\frac{\delta C}{\delta A}) = \text{dim}(A) = (m,n)$</p>
  </li>
  <li>
    <p>Any guess we come up with should reduce to the special case $\frac{\delta C}{\delta A} = yx^T$ when $\sigma = id$, the identity function, $id(x) = x$, which is the result we derived in Section III.</p>
  </li>
</ul>

<p>Let’s look at how we can combine these terms to get something with dimensions = $(m,n)$:</p>

<ul>
  <li>$y x^T$</li>
  <li>$A$ but this shouldn’t show up directly if we follow the intuition that the derivative of a linear function $f(x) = ax$ with respect to $a$ should be independent of $a$.</li>
  <li>We can replace $y$ with $\sigma’(Ax)$ since $\text{dim}(Ax) = \text{dim}(\sigma(Ax)) = \text{dim}(\sigma’(Ax)) = \text{dim}(y) = (m,1)$ i.e. $Ax$ has the same dimensions as $y$ and acting with element-wise functions, whether $\sigma$ or $\sigma’$ doesn’t change dimensions. So another option is $\sigma’(Ax) x^T$.</li>
</ul>

<p>How do we combine both $yx^T$ and $\sigma’(Ax) x^T$ since both terms have the correct dimensions $(m,n)$ required for $\frac{\delta C}{\delta A}$ and we need the derivative to be linear in $y$ (requiring the first term) and it needs to contain $\sigma’(Ax)$ (requiring the second term).</p>

<p>Since we are unsure, let’s explicitly calculate the derivative:</p>

<p>$C = y^T \sigma(Ax) = (y_1 y_2 \ldots y_m) \begin{bmatrix}
\sigma(a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n) \\
\sigma(a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n) \\
\vdots \\
\sigma(a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n) \\
\end{bmatrix}$</p>

<p>$C = y_1 \sigma(a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n) + \\ y_2 \sigma(a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n) + \\ \ldots + y_m \sigma(a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n)$.</p>

<p>Differentiating with respect to $a_{kl}$, we get</p>

<p>$\frac{\partial C}{\partial a_{kl}} = y_k \sigma’(a_{k1}x_1 + a_{k2} x_2 + \ldots a_{kn} x_n) x_l = y_k [\sigma’(Ax)]_{k} x_l$</p>

<p>where $[\sigma’(Ax)]_{k}$ denotes the $k$th element of $\sigma’(Ax)$</p>

<p>Contrast this to what we got in Section III without activation functions. There the same exact derivative gave us $y_k x_l$. The fact that we see a term $y_k [\sigma’(Ax)]_{k}$ tells us that we need to define an element-wise multiplication operation:</p>

<script type="math/tex; mode=display">x \odot y</script>

<p>that takes two vectors of the same dimensions and just multiplies the corresponding elements together:</p>

<script type="math/tex; mode=display">x \odot y = \begin{bmatrix}
x_1 \\\
x_2 \\\
\ldots \\\
x_n
\end{bmatrix} \odot
\begin{bmatrix}
y_1 \\\
y_2 \\\
\ldots \\\
y_n
\end{bmatrix} = \begin{bmatrix}
x_1 y_1 \\\
x_2 y_2 \\\
\ldots \\\
x_n y_n
\end{bmatrix}</script>

<p>It looks like a weird operation but just pops out of our calculation. Using this notation, we just showed</p>

<script type="math/tex; mode=display">\frac{\partial C}{\partial a_{kl}} = [y \odot\sigma'(Ax)]_k x_l</script>

<p>and</p>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta A} = [y \odot \sigma'(Ax)] x^T}</script>

<p>which combines both the terms we guessed we needed, $yx^T$ and $\sigma’(Ax)x^T$ using a new operation.</p>

<p>Time for a sanity check. If there was no activation function or more formally, if the activation function was the identity function $\sigma(x) = id(x) = x$, then we expect to recover $yx^T$. Let’s see if this is the case.</p>

<p>If $\sigma(x) = id(x) = x$, then $\sigma’(x) = id’(x) = 1$, no matter what $x$ is. This would give:</p>

<p>$\sigma’(Ax) = \begin{bmatrix}
1 \\
1 \\
\vdots \\
1 \\
\end{bmatrix}$</p>

<p>and $y \odot \sigma’(Ax) = y \odot \begin{bmatrix}
1 \\
1 \\
\vdots \\
1 \\
\end{bmatrix} = \begin{bmatrix}
y_1*1 \\
y_2*1 \\
\vdots \\
y_m *1 \\
\end{bmatrix} = y$</p>

<p>So, we would get:</p>

<script type="math/tex; mode=display">\frac{\delta C}{\delta A} = [y \odot \sigma'(Ax)] x^T = y x^T</script>

<p>which is what we expected.</p>

<p>We need to now develop some intuition to see what these derivatives would look like if the matrix $A$ was nested the way forward propagation nests weight matrices. In other words, what if</p>

<script type="math/tex; mode=display">C = y^T \sigma_2(A\sigma_1(B x))</script>

<p>We now have two derivatives: $\frac{\delta C}{\delta A}, \frac{\delta C}{\delta B}$.</p>

<p>$\frac{\delta C}{\delta A}$:</p>

<p>This is the easier one. Define $q = \sigma_1(Bx)$ to give:</p>

<p>$C = y^T \sigma_2(A\underbrace{\sigma_1(B x)}_{q}) = y^T \sigma_2(Aq)$</p>

<p>From our previous calculation, we know</p>

<p>$\frac{\delta C}{\delta A} = [y \odot \sigma_2’(Aq)]q^T = \boxed{[y \odot \sigma_2’(A\sigma_1(Bx))] \sigma_1(Bx)^T}$</p>

<p>Recall from section III that we guessed a rule that a matrix derivative transposes every constant vector it sees. The same phenomenon occurs here too. Let’s see it step by step:</p>

<p>$\frac{\delta C}{\delta A} = \frac{\delta}{\delta A} (y^T \sigma_2(A\sigma_1(B x)))$</p>

<p>$\frac{\delta C}{\delta A} = y \frac{\delta}{\delta A}(\sigma_2(A\sigma_1(B x)))$</p>

<p>Now, using the chain rule, we get $\sigma_2’$ and a preceding $\odot$:</p>

<p>$\frac{\delta C}{\delta A} = y \odot \sigma_2’(A\sigma_1(B x)) \frac{\delta}{\delta A}(A\sigma_1(B x))$</p>

<p>Since, $\sigma_1(Bx)$ is a constant with respect to $A$, it has to get transposed.</p>

<p>$\frac{\delta C}{\delta A} = y \odot \sigma_2’(A\sigma_1(B x)) \frac{\delta}{\delta A}(A) (\sigma_1(B x))^T$</p>

<p>Using $\frac{\delta A}{\delta A} = 1$, we get our final answer:</p>

<p>$\frac{\delta C}{\delta A} = [y \odot \sigma_2’(A\sigma_1(B x)] \sigma_1(B x)^T$</p>

<p>That’s great! Now we only need to follow these rules and not worry about the details of what goes on underneath.</p>

<p>Let’s see if we can apply these rules to guess what $\frac{\delta C}{\delta B}$ should look like and then we’ll explicitly compute it:</p>

<p><strong>Using imputed rules</strong>:</p>

<p>$\frac{\delta C}{\delta B} = \frac{\delta}{\delta B} (y^T \sigma_2(A\sigma_1(B x)))$</p>

<p>Tranpose “constant” vector $y$:</p>

<p>$\frac{\delta C}{\delta B} = y \frac{\delta}{\delta B} (\sigma_2(A\sigma_1(B x)))$</p>

<p>Apply chain rule i.e. differentiate the function and put $\odot$ before it:</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] \frac{\delta}{\delta B} (A\sigma_1(Bx))$</p>

<p>Tranpose constant matrix $A$:</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] A^T \frac{\delta}{\delta B} (\sigma_1(Bx))$</p>

<p>Use chain rule again:</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] A^T \odot \sigma_1’(Bx) \frac{\delta}{\delta B} (B x)$</p>

<p>Transpose “constant” vector $x$:</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] A^T \odot \sigma_1’(Bx) \frac{\delta}{\delta B} (B) x^T$</p>

<p>Use $\frac{\delta B}{\delta B} = 1$,</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] A^T \odot \sigma_1’(Bx) x^T$</p>

<p>The big question now is if this is correct?</p>

<p>Let’s check if the dimensions work out.</p>

<script type="math/tex; mode=display">C = \underbrace{y^T}_{(1,k)} \sigma_2(\underbrace{A}_{(k,m)}\sigma_1(\underbrace{B}_{(m,n)} \underbrace{x}_{(n,1)}))</script>

<p>So $\text{dim}(y) = \text{dim}(\sigma_2’(A\sigma_1(Bx))) = (k,1)$ and $y \odot \sigma_2’(A\sigma_1(Bx))$ is well-defined.</p>

<p>This term is then multiplied by $A^T$ on the right i.e.:</p>

<p>$[y \odot \sigma_2’(A\sigma_1(Bx))] A^T$</p>

<p>Oops! this is not well-defined! $\text{dim}(A^T) = (m,k)$ so we have a multiplication of the form $(k,1)(m,k)$.</p>

<p>Let’s see if we can salvage this (don’t worry, we’ll confirm all our guesses with explicit calculations below). While $(k,1)(m,k)$ is not well-defined, $(m,k)(k,1)$ is. So, maybe the rule is that the $A^T$ should be tacked on in front of everything to its left i.e.</p>

<p>$\frac{\delta C}{\delta B} = A^T [y \odot \sigma_2’(A\sigma_1(Bx))] \frac{\delta}{\delta B} (\sigma_1(Bx))$</p>

<p>Does this weird rule make sense? Of course! Imagine we had</p>

<p>$\frac{\delta }{\delta A} (y^T B^T A x)$</p>

<p>We can view this in two ways. The first one is to treat one term at a time:</p>

<p>$\frac{\delta }{\delta A} (y^T B^T A x) = y \frac{\delta }{\delta A} (B^T A x) = y B \frac{\delta }{\delta A} (Ax) = y B x^T$</p>

<p>The second one is to realize that $y^T B^T$ is a constant term and can be grouped together:</p>

<p>$\frac{\delta }{\delta A} (y^T B^T A x) = (y^T B^T)^T \frac{\delta }{\delta A} (A x) = Byx^T$</p>

<p>Now we see the problem. When we treat one term at a time, we are transposing constant terms but $(AB)^T \neq A^T B^T$. Instead it is $B^T A^T$. So, every time we see a constant term, we need to transpose it AND tack it on the left of everything.</p>

<p>$\frac{\delta }{\delta A} (y^T B^T A x) = y \frac{\delta }{\delta A} (B^T A x) = {\color{red} {B y}} \frac{\delta }{\delta A} (Ax) = y B x^T$</p>

<p>Going back to our original calculation:</p>

<p>$\frac{\delta C}{\delta B} = \frac{\delta}{\delta B} (y^T \sigma_2(A\sigma_1(B x)))$</p>

<p>Tranpose “constant” vector $y$:</p>

<p>$\frac{\delta C}{\delta B} = y \frac{\delta}{\delta B} (\sigma_2(A\sigma_1(B x)))$</p>

<p>Apply chain rule i.e. differentiate the function and put $\odot$ before it:</p>

<p>$\frac{\delta C}{\delta B} = [y \odot \sigma_2’(A\sigma_1(Bx))] \frac{\delta}{\delta B} (A\sigma_1(Bx))$</p>

<p>Tranpose constant matrix $A$ AND put it to the left of the previous term:</p>

<p>$\frac{\delta C}{\delta B} = A^T [y \odot \sigma_2’(A\sigma_1(Bx))] \frac{\delta}{\delta B} (\sigma_1(Bx))$</p>

<p>Use chain rule again:</p>

<p>$\frac{\delta C}{\delta B} = A^T [y \odot \sigma_2’(A\sigma_1(Bx))] \odot \sigma_1’(Bx) \frac{\delta}{\delta B} (B x)$</p>

<p>Transpose “constant” vector $x$:</p>

<p>$\frac{\delta C}{\delta B} = A^T [y \odot \sigma_2’(A\sigma_1(Bx))] \odot \sigma_1’(Bx) \frac{\delta}{\delta B} (B) x^T$</p>

<p>Use $\frac{\delta B}{\delta B} = 1$,</p>

<script type="math/tex; mode=display">\boxed{\frac{\delta C}{\delta B} = \{[A^T [y \odot \sigma_2'(A\sigma_1(Bx))] \odot \sigma_1'(Bx)\} x^T}</script>

<p>Now all the dimensions are well-defined:</p>

<p>$\text{dim}[A^T [y \odot \sigma_2’(A\sigma_1(Bx))]] = (m,1)$</p>

<p>$\text{dim} [\sigma_1’(Bx)] = (m,1)$</p>

<p>So, $\text{dim} [A^T [y \odot \sigma_2’(A\sigma_1(Bx))] \odot \sigma_1’(Bx)] = (m,1)$</p>

<p>and $\text{dim}(x^T) = (1,n)$</p>

<p>to give:</p>

<p>$\text{dim}(\frac{\delta C}{\delta B}) = (m,n) = \text{dim}(B)$!</p>

<p>Let’s also check that if $\sigma_1 = id$, we basically recover the previous case using $\sigma’(x) = 1$ and $\odot$ing with a vector of $1$s gives the original vector back:</p>

<p>$\frac{\delta C}{\delta B} = A^T [y \odot \sigma_2’(A\sigma_1(Bx))] x^T = A^T [y \odot \sigma_2’(ABx)] x^T$</p>

<p>If $A = I$, the identity matrix (diagonals are $1$ and everything else is $0$), we get:</p>

<p>$\frac{\delta C}{\delta B} = y \odot \sigma_2’(Bx)] x^T$</p>

<p>as expected.</p>

<p>We have another (ugly) way of confirming this calculation and while it’s not pretty, we have to confirm as many ways as we can:</p>

<p><strong>Explicit calculation</strong></p>

<p>$C = y^T \sigma_2(A\sigma_1(B x))$</p>

<h4 id="cost-quadratic-in-weights-1">Cost quadratic in weights</h4>

<p>Let’s start with a simple quadratic cost:</p>

<p>$C = \frac{1}{2} \sigma(x^TA^T)\sigma(Ax)$</p>

<p>We have done most of the hard work above. Let’s now compute the derivative using both our imputed rules and explicitly to ensure they match.</p>

<p><strong>Imputed Rules</strong></p>

<p>$\frac{\delta C}{\delta A} = \frac{\delta}{\delta A} [\frac{1}{2} \sigma(x^TA^T)\sigma(Ax)]$</p>

<p>$\frac{\delta C}{\delta A} = \frac{1}{2} [\frac{\delta \sigma(x^TA^T)}{\delta A}\sigma(Ax) + \sigma(x^TA^T)\frac{\delta \sigma(xA)}{\delta A}]$</p>

<p>The two derivatives are equal since the terms are just transposed. We can combine them and get rid of the factor of $\frac{1}{2}$:</p>

<p>$\frac{\delta C}{\delta A} = \sigma(x^TA^T)\frac{\delta \sigma(xA)}{\delta A}$</p>

<h3 id="end-of-aside-on-matrix-derivatives-1">End of Aside on Matrix derivatives</h3>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Happy Mathematician</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>The Happy Mathematician</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/treeinrandomforest"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">treeinrandomforest</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
